<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>多洛的黑猫</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-14T05:02:22.272Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>thor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java笔记综合</title>
    <link href="http://yoursite.com/2019/02/14/Java%E5%90%8E%E7%AB%AF%E7%89%B9%E6%AE%8A%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/02/14/Java后端特殊细节记录/</id>
    <published>2019-02-14T05:02:22.000Z</published>
    <updated>2019-02-14T05:02:22.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java后端特殊细节"><a href="#Java后端特殊细节" class="headerlink" title="## Java后端特殊细节"></a><strong>## Java后端特殊细节</strong></h2><p><strong><em>1.</em></strong>java中的实例变量：<strong>**</strong><br><strong>含义</strong>：<br>实例变量：定义在类中但<strong>在任何方法之外</strong>。（New出来的均有初始化）<br><strong>与局部变量的异同：</strong><br>(局部变量：定义在方法之中的变量）</p><ol><li><p>局部变量要先赋值，再进行运算，而实例变量均已经赋初值。</p></li><li><p>实例变量的对象赋初值为null。</p></li><li><p>局部变量不允许范围内定义两个同名变量。实例变量的作用域在本类中完全有效，当被其他的类调用的时候也可能有效。</p></li><li><p>实例变量和局部变量都允许命名冲突。<br>代码实例：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Sample</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">private int a=1; //实例变量</span><br><span class="line"></span><br><span class="line">public void b()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int a=2; //局部变量</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;局部变量:a=&quot;+a);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;实例变量:a=&quot;+this.a);//局部变量的作用域内引用实例变量方法:this.变量名</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">new Sample().b();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>2.构造器：</em></strong><br>构造器就是<strong>和类名相同</strong>但<strong>无返回类型</strong>的方法。创建构造器就是构建特定方法。而构造器最大的用处就是<em>在创建对象时执行初始化</em>。每当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。<br>比如 </p><pre><code>class A {    public A()    {    }}//其中A方法 就是class A的构造器 虽然构造器没有返回值但可以有参数如class A {    public A(String a,String b)    {    }}一个类也可以有多个构造器如class A {    public A()    {    }     public A(String a,String b)    {    }}</code></pre><p>当你new A（）时，无参那个构造器被调用，当你new A（”ddd”,”fff”）时，那个有参的构造器被调用，如果你没有写构造器则jvm会调用一个<strong>默认的无参的构造器</strong>（故调用父类默认构造器的条件：子类没有声明任何构造器；编译器为子类加的缺省构造器一定为无参数的构造器；父类一定要存在一个无参数的构造器）。</p><p>PS：构造器在类初始化的时候被调用通常被用来做一些初始化的工作。<br><strong><em>构造器与方法的具体差异：</em></strong><br><strong>1、功能和作用的不同</strong><br>构造器是为了创建一个类的实例。用来创建一个对象，同时可以给属性做初始化。这个过程也可以在创建一个对象的时候用到：Platypus p1 = new Platypus();</p><p>相反，方法的作用仅仅是功能函数，执行java代码。</p><p><strong>2、修饰符，返回值和命名的不同</strong></p><p>和方法一样，构造器可以有任何访问的修饰： public, protected, private或者没有修饰. 不同于方法的是，构造器不能有以下<strong>非访问性质</strong>的修饰： abstract, final, native, static, 或者 synchronized。</p><p><strong>3、返回类型</strong></p><p> <strong>方法必须要有返回值</strong>，能返回任何类型的值或者空返回值（void），构造器没有返回值，也不需要void。</p><p><strong>4、命名</strong></p><p><strong>构造器使用和类相同的名字</strong>，而方法则不同。按照习惯，方法通常用小写字母开始，而构造器通常用大写字母开始。</p><p>构造器通常是一个名词，因为它和类名相同；而方法通常更接近动词，因为它说明一个操作。</p><p><strong>5、调用</strong></p><p>构造：只有在对象创建的时候才会去调用，而且只会调用一次。</p><p> 方法：在对象创建之后才可以调用，并且可以调用多次。</p><p><strong>6、”this”的用法</strong></p><p>方法引用this指向<strong>正在执行方法的类的实例</strong>。静态方法不能使用this关键字，因为<strong>静态方法不属于类的实例</strong>，所以this也就没有什么东西去指向。构造器的this指向<strong>同一个类</strong>中，不同参数列表的另外一个构造器。下面的代码：</p><pre><code>public class Platypus { String name; Platypus(String input) { name = input; } Platypus() { this(&quot;John/Mary Doe&quot;); } public static void main(String args[]) { Platypus p1 = new Platypus(&quot;digger&quot;); Platypus p2 = new Platypus(); } } </code></pre><p>在代码中，有2个不同参数列表的构造器。第一个构造器，给类的成员name赋值，第二个构造器，调用第一个构造器，给成员变量name一个初始值 “John/Mary Doe”.</p><p>在构造器中，如果要使用关键字this,那么必须放在第一行，如果不这样将导致一个编译错误。<br><strong>7、继承</strong></p><p>构造器是<strong>不能被继承</strong>的。子类可以继承超类的任何方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java后端特殊细节&quot;&gt;&lt;a href=&quot;#Java后端特殊细节&quot; class=&quot;headerlink&quot; title=&quot;## Java后端特殊细节&quot;&gt;&lt;/a&gt;&lt;strong&gt;## Java后端特殊细节&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>helloworld</title>
    <link href="http://yoursite.com/2019/02/13/helloworld/"/>
    <id>http://yoursite.com/2019/02/13/helloworld/</id>
    <published>2019-02-13T11:23:22.000Z</published>
    <updated>2019-02-13T15:55:14.759Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是你好师姐<br>雷猴</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章是你好师姐&lt;br&gt;雷猴&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="hello" scheme="http://yoursite.com/tags/hello/"/>
    
  </entry>
  
</feed>
