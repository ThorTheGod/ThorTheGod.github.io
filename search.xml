<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo博客设计]]></title>
    <url>%2F2019%2F02%2F26%2Fhexo%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node杂笔记]]></title>
    <url>%2F2019%2F02%2F14%2Fnode.js%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[写在前面：由于所学不精，不够系统，笔记只记了感觉容易遗忘的知识点。仅供参考。 node.js的三个特点：1.单线程：在java，PHP或net等服务器端语言中会为每一个客户端链接创建见一个新的线程，每个线程耗费大约2mb内存——即8gb内存服务器可以同时连接最多4000个用户（故需要增加服务器数量）。而node.js仅使用一个线程（不健壮，但约20mb）。当用户连接会触发内部事件，通过非阻塞和事件驱动机制让js宏观上并行。8gb内存——40000用户。当前请求（计算）暂停，其他请求放入事件站循环，当当前请求需要数据库时会被放入事件站中，即：i/o读数据库，这个过程中node.js可以处理下一个请求，直到i/o返回值，继续进行前请求。使操作系统完全不再有线程创建·销毁的事件开销能使cpu利用率百分之百一个用户线程的崩溃将导致所有用户线程崩溃。2.非阻塞i/o：传统的线程处理机制中，执行了i/o访问数据库代码后，整个线程都讲停下来等待数据库返回值，随后进行下一步代码。即这种机制下的i/o阻塞了程序的执行。而node.js在执行访问数据库时会立即执行后面的代码如：fs.readfile(“text1”,function(){ } a++;其中a++语句不会被访问数据库代码阻塞运行。机制：线程的事件循环不断检查是否有未处理的事件并依次处理。完成事件的调动。3.事件驱动：客户端请求连接，提交数据等行为会触发相应的事件（node中同一时刻一个线程只能执行一个回调函数，中途可以处理其他事件——事件环）*node适合有大量并发i/o但响应前不需要复杂计算的程序（擅长i/o即任务调动单不擅长计算） node不适合需要极高可靠性的业务。（是一种小工具但不健壮） 我的第一次node代码var http=require("http"); //require表示引包，即引用自己的一个特殊功能 var server = http.createServer(function(req,res){ //创建服务器，参数为回调函数，表示若有请求则执行什么 res.writeHead(200,{"Content-type":"text/html;charset=UTF-8"}); //设置http头部，状态码为200，文件类型为html，字符类型为utf-8 res.end("ancsjannaalscmafwrf" + (1+2+3) +"s"); }); server.listen(3000,"127.0.0.1"); //运行服务器，监听3000端口 ctrl+c可以中断挂起服务器终端输入cd:\xxx表示进入某个文件，dir显示文件中的子文件tab自动补全 node.js没有根目录的概念——没有任何web容器，路由相关。 所以它很难提供静态服务。 查询字符串的模块：url和querystring var http=require("http");var url = require("url'); //url.parse（）可以将一个完整的url地址分开为href协议，slashes斜杠，host主机名，端口号port，路径pathname，path（带上地址后的query），query（用户字符串） var path = url.parse(req.url).pathname; //路径 var query = url.parse(req.url).query; //var query = url.parse(req.url，true).query;这里的true把长串转换成对象。即把查询遍为对象，直接打点来得到相应的参数。相当于querystring函数。 //var一个age =query.age再console.log便可以把query里的age提取并输出出来 //查询的东西 console.log(path); console.log("query"+query); querystring.parse（'foo=bar&abc=xyz&abc=123'） //returns { foo: 'bar', abc: ['xyz', '123'] } // 假设存在 gbkDecodeURIComponent 函数。 //规定编码方式 querystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null, { decodeURIComponent: gbkDecodeURIComponent }); 运行流程：写好html和node.js后，进入cmd，cd打开node.js代码所在的文件夹后，输入node xxx.js运行js文件，即可实现运行。 WebSocket协议允许了服务器主动发送信息给客户端。用ws模块搭建websocket： // 导入WebSocket模块: const WebSocket = require('ws'); // 引用Server类: const WebSocketServer = WebSocket.Server; // 实例化: const wss = new WebSocketServer({ port: 3000 });]]></content>
      <categories>
        <category>node</category>
        <category>nodenote</category>
      </categories>
      <tags>
        <tag>非教学</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端杂笔]]></title>
    <url>%2F2019%2F02%2F14%2Fhtml%EF%BC%8Ccss%E5%92%8Cjs%E5%AD%A6%E4%B9%A0%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[写在前面：由于所学不精，不够系统，笔记只记了感觉容易遗忘的知识点。仅供参考。 消除列表原点： list-style：none||list-style-type：none 消除链接下划线：text-decoration：none（应用于 ） 对元素设置display：block使其变成块元素，如：a{display:block;}可以把a相应的链接方式变成块状点击。 text-align是将文本中央对齐于块中 语义部分：(1). strong 是标明重点内容， 有语气加强的含义， 使用阅读设备阅读网络时会重读， 而是展示强调内容。strong 是标明重点内容， 有语气加强的含义， 使用阅读设备阅读网络时会重读， 而是展示强调内容。i 内容展示为斜体， em 表示强调的文本；(2).自然样式标签b, i, u, s, pre语义样式标签strong, em, ins, del, code**(3).]]></content>
      <categories>
        <category>web</category>
        <category>html &amp; css</category>
      </categories>
      <tags>
        <tag>非教学</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java笔记综合]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E5%90%8E%E7%AB%AF%E7%89%B9%E6%AE%8A%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[写在前面：由于所学不精，不够系统，笔记只记了感觉容易遗忘的知识点。仅供参考。 ##Java后端特殊细节1.java中的实例变量：**含义：实例变量：定义在类中但在任何方法之外。（New出来的均有初始化）与局部变量的异同：(局部变量：定义在方法之中的变量） 局部变量要先赋值，再进行运算，而实例变量均已经赋初值。 实例变量的对象赋初值为null。 局部变量不允许范围内定义两个同名变量。实例变量的作用域在本类中完全有效，当被其他的类调用的时候也可能有效。 实例变量和局部变量都允许命名冲突。代码实例： 123456789101112131415161718192021222324252627public class Sample{private int a=1; //实例变量public void b(){int a=2; //局部变量System.out.println("局部变量:a="+a);System.out.println("实例变量:a="+this.a);//局部变量的作用域内引用实例变量方法:this.变量名}public static void main(String[] args){new Sample().b();}} 2.构造器：构造器就是和类名相同但无返回类型的方法。创建构造器就是构建特定方法。而构造器最大的用处就是在创建对象时执行初始化。每当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。比如 class A { public A() { } } //其中A方法 就是class A的构造器 虽然构造器没有返回值但可以有参数如 class A { public A(String a,String b) { } } 一个类也可以有多个构造器如 class A { public A() { } public A(String a,String b) { } } 当你new A（）时，无参那个构造器被调用，当你new A（”ddd”,”fff”）时，那个有参的构造器被调用，如果你没有写构造器则jvm会调用一个默认的无参的构造器（故调用父类默认构造器的条件：子类没有声明任何构造器；编译器为子类加的缺省构造器一定为无参数的构造器；父类一定要存在一个无参数的构造器）。 PS：构造器在类初始化的时候被调用通常被用来做一些初始化的工作。构造器与方法的具体差异：1、功能和作用的不同构造器是为了创建一个类的实例。用来创建一个对象，同时可以给属性做初始化。这个过程也可以在创建一个对象的时候用到：Platypus p1 = new Platypus(); 相反，方法的作用仅仅是功能函数，执行java代码。 2、修饰符，返回值和命名的不同 和方法一样，构造器可以有任何访问的修饰： public, protected, private或者没有修饰. 不同于方法的是，构造器不能有以下非访问性质的修饰： abstract, final, native, static, 或者 synchronized。 3、返回类型 方法必须要有返回值，能返回任何类型的值或者空返回值（void），构造器没有返回值，也不需要void。 4、命名 构造器使用和类相同的名字，而方法则不同。按照习惯，方法通常用小写字母开始，而构造器通常用大写字母开始。 构造器通常是一个名词，因为它和类名相同；而方法通常更接近动词，因为它说明一个操作。 5、调用 构造：只有在对象创建的时候才会去调用，而且只会调用一次。 方法：在对象创建之后才可以调用，并且可以调用多次。 6、”this”的用法 方法引用this指向正在执行方法的类的实例。静态方法不能使用this关键字，因为静态方法不属于类的实例，所以this也就没有什么东西去指向。构造器的this指向同一个类中，不同参数列表的另外一个构造器。下面的代码： public class Platypus { String name; Platypus(String input) { name = input; } Platypus() { this("John/Mary Doe"); } public static void main(String args[]) { Platypus p1 = new Platypus("digger"); Platypus p2 = new Platypus(); } } 在代码中，有2个不同参数列表的构造器。第一个构造器，给类的成员name赋值，第二个构造器，调用第一个构造器，给成员变量name一个初始值 “John/Mary Doe”. 在构造器中，如果要使用关键字this,那么必须放在第一行，如果不这样将导致一个编译错误。7、继承 构造器是不能被继承的。子类可以继承超类的任何方法。]]></content>
      <categories>
        <category>java</category>
        <category>javanote</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>非教学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[helloworld]]></title>
    <url>%2F2019%2F02%2F13%2Fhelloworld%2F</url>
    <content type="text"><![CDATA[这篇文章是你好师姐雷猴]]></content>
  </entry>
</search>
