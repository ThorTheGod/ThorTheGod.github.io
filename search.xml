<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node杂笔记]]></title>
    <url>%2F2019%2F02%2F14%2Fnode.js%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[node.js的三个特点：1.单线程：在java，PHP或net等服务器端语言中会为每一个客户端链接创建见一个新的线程，每个线程耗费大约2mb内存——即8gb内存服务器可以同时连接最多4000个用户（故需要增加服务器数量）。而node.js仅使用一个线程（不健壮，但约20mb）。当用户连接会触发内部事件，通过非阻塞和事件驱动机制让js宏观上并行。8gb内存——40000用户。当前请求（计算）暂停，其他请求放入事件站循环，当当前请求需要数据库时会被放入事件站中，即：i/o读数据库，这个过程中node.js可以处理下一个请求，直到i/o返回值，继续进行前请求。使操作系统完全不再有线程创建·销毁的事件开销能使cpu利用率百分之百一个用户线程的崩溃将导致所有用户线程崩溃。2.非阻塞i/o：传统的线程处理机制中，执行了i/o访问数据库代码后，整个线程都讲停下来等待数据库返回值，随后进行下一步代码。即这种机制下的i/o阻塞了程序的执行。而node.js在执行访问数据库时会立即执行后面的代码如：fs.readfile(“text1”,function(){ } a++;其中a++语句不会被访问数据库代码阻塞运行。机制：线程的事件循环不断检查是否有未处理的事件并依次处理。完成事件的调动。3.事件驱动：客户端请求连接，提交数据等行为会触发相应的事件（node中同一时刻一个线程只能执行一个回调函数，中途可以处理其他事件——事件环）*node适合有大量并发i/o但响应前不需要复杂计算的程序（擅长i/o即任务调动单不擅长计算） node不适合需要极高可靠性的业务。（是一种小工具但不健壮） 我的第一次node代码var http=require(&quot;http&quot;); require表示引包，即引用自己的一个特殊功能 var server = http.createServer(function(req,res){ 创建服务器，参数为回调函数，表示若有请求则执行什么 res.writeHead(200,{&quot;Content-type&quot;:&quot;text/html;charset=UTF-8&quot;}); 设置http头部，状态码为200，文件类型为html，字符类型为utf-8 res.end(&quot;ancsjannaalscmafwrf&quot; + (1+2+3) +&quot;s&quot;); }); server.listen(3000,&quot;127.0.0.1&quot;); 运行服务器，监听3000端口 ctrl+c可以中断挂起服务器终端输入cd:\xxx表示进入某个文件，dir显示文件中的子文件tab自动补全 node.js没有根目录的概念——没有任何web容器，路由相关。 所以它很难提供静态服务。 查询字符串的模块：url和querystring var http=require(&quot;http&quot;);var url = require(&quot;url&#39;); //url.parse（）可以将一个完整的url地址分开为href协议，slashes斜杠，host主机名，端口号port，路径pathname，path（带上地址后的query），query（用户字符串） var path = url.parse(req.url).pathname; //路径 var query = url.parse(req.url).query; //var query = url.parse(req.url，true).query;这里的true把长串转换成对象。即把查询遍为对象，直接打点来得到相应的参数。相当于querystring函数。 //var一个age =query.age再console.log便可以把query里的age提取并输出出来 //查询的东西 console.log(path); console.log(&quot;query&quot;+query); querystring.parse（&#39;foo=bar&amp;abc=xyz&amp;abc=123&#39;） //returns { foo: &#39;bar&#39;, abc: [&#39;xyz&#39;, &#39;123&#39;] } // 假设存在 gbkDecodeURIComponent 函数。 //规定编码方式 querystring.parse(&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;, null, null, { decodeURIComponent: gbkDecodeURIComponent }); 运行流程：写好html和node.js后，进入cmd，cd打开node.js代码所在的文件夹后，输入node xxx.js运行js文件，即可实现运行。 WebSocket协议允许了服务器主动发送信息给客户端。用ws模块搭建websocket： // 导入WebSocket模块: const WebSocket = require(&apos;ws&apos;); // 引用Server类: const WebSocketServer = WebSocket.Server; // 实例化: const wss = new WebSocketServer({ port: 3000 });]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端杂笔]]></title>
    <url>%2F2019%2F02%2F14%2Fhtml%EF%BC%8Ccss%E5%92%8Cjs%E5%AD%A6%E4%B9%A0%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[消除列表原点： list-style：none||list-style-type：none 消除链接下划线：text-decoration：none（应用于 ） 对元素设置display：block使其变成块元素，如：a{display:block;}可以把a相应的链接方式变成块状点击。 text-align是将文本中央对齐于块中 语义部分：(1). strong 是标明重点内容， 有语气加强的含义， 使用阅读设备阅读网络时会重读， 而是展示强调内容。strong 是标明重点内容， 有语气加强的含义， 使用阅读设备阅读网络时会重读， 而是展示强调内容。i 内容展示为斜体， em 表示强调的文本；(2).自然样式标签b, i, u, s, pre语义样式标签strong, em, ins, del, code**(3).&lt;span标签是没有语义的，它的作用就是为了设置单独的样式。把一段话圈起来，然后用css设置样式。(4).语义化的作用1更容易被搜索引擎收录。2 更容易让屏幕阅读器读出网页内容。(5).引用这里用标签的真正关键点不是它的默认样式双引号而是它的语义：引用别人的话. display 有哪些值？ 说明他们的作用block 块类型。 默认宽度为父元素宽度， 可设置宽高， 换行显示。none 缺省值。 象行内元素类型一样显示。 即隐藏不展示inline 行内元素类型。 默认宽度为内容宽度， 不可设置宽高， 同行显示。inline-block 默认宽度为内容宽度， 可以设置宽高， 同行显示。list-item 象块类型元素一样显示， 并添加样式列表标记。table 此元素会作为块级表格来显示。inherit 规定应该从父元素继承 display 属性的值。 margin 是用来隔开元素与元素的间距； padding 是用来隔开元素与内容的间隔。margin 用于布局分开元素使元素与元素互不相干；padding 用于元素与内容之间的间隔， 让内容（ 文字） 与（ 包裹） 元素之间有一段距离。 &lt;br/换行 &lt;hr/分割线（可用css修改线的样式） img语法：&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt;举例：src 12345678910讲解：1、src：标识图像的位置；2、alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本；3、title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)；4、图像可以是GIF，PNG，JPEG格式的图像文件。10. 文本域textarea支持多行文本输入当用户需要在表单中输入大段文字时，需要用到文本输入域。语法：```&lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt; 1、标签是成对出现的，以123452、cols ：多行输入域的列数。3、rows ：多行输入域的行数。 11. 单选框，复选框语法：```&lt;input type=&quot;radio/checkbox&quot; value=&quot;值&quot; name=&quot;名称&quot; checked=&quot;checked&quot;/&gt; 1、type: 当type=”radio”时，控件为单选框 当type=”checkbox”时，控件为复选框2、value：提交数据到服务器的值（后台程序PHP使用）3、name：为控件命名，以备后台程序ASP、PHP使用4、checked：当设置checked=”checked”时，该选项被默认选中注意：同一组的单选按钮，name取值一定要一致，这样同一组的单选按钮才可以起到单选的作用 Label 的作用是什么？是怎么用的？label 标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单上。例子：for1```&lt;input type=&quot;text&quot; name=&quot;Name&quot; id=&quot;Name&quot;/&gt; type12345678910111213141516171819202122232412. placeholder属性可以提供输入字段预期值展示，在输入时消失。 适用于以下的&lt;input&gt;类型：text，search，url，telephone，password和email。13. ```&lt;input type=&quot;reset&quot; value=重置&gt;```为重置按钮，当点击后使输入框重置。注意：此按钮会重置所有输入框内容。 14. 伪类选择符伪类选择符允许给html不存在的标签设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：a:hover&#123;color:red;&#125;这行代码会使被&lt;a&gt;&lt;/a&gt;标签包裹的文字内容中的“胆小如鼠”字体颜色在鼠标滑过时变为红色。15. 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。例如下面的代码：p&#123;color:red;&#125; /*权值为1*/p span&#123;color:green;&#125; /*权值为1+1=2*/.warning&#123;color:white;&#125; /*权值为10*/p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/16. 重要性优先我们在做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，怎么办？这时候我们可以使用!important来解决。如下代码：p&#123;color:red!important;&#125;p&#123;color:green;&#125;```&lt;p class=&quot;first&quot;&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 这时 p 段落中的文本会显示的red红色。注意：!important要写在分号的前面。 删除线： p a{text-decoration:line-through;} 1，段落缩进中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：p{text-indent:2em;} 2，段落排版--行间距 行间距属性（line-height），如下代码实现设置段落行间距为1.5倍。p{line-height:1.5em;} 3，段落排版--字间距、字母间距 **文字**间隔、**字母**间隔设置： 如果想在网页排版中设置文字间隔或者字母间隔就可以使用 letter-spacing来实现，如下面代码： h1{ letter-spacing:50px; } &lt;h1&gt;了不起的盖茨比&lt;/h1&gt; 注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。 单词间距设置： 使用word-spacing来实现。如下代码： h1{ word-spacing:50px; to imooc!```12319. 常用的块状元素有：```&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 常用的内联元素有：12常用的内联块状元素有：```&lt;img&gt;、&lt;input&gt; 块级元素特点： 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。2、元素的高度height、宽度width、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 行内元素相反。 内联块级元素： inline-block元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。 盒模型： （1）边框border：盒子模型的边框就是围绕着内容及补白的线。拥有3个属性：粗细（border-width）、样式（-style&lt;虚线dashed，点线dotted，实线solid&gt;）和颜色（-color），分为border-top，-bottom，-left，-right四边。 （2）边界margin：元素与其它元素之间的距离可以使用margin来设置。边界也是可分为上、右、下、左（顺序）。下代码： div{margin:20px 10px 15px 30px;}也可以分开写：div{margin-top:20px;margin-right:10px;margin-bottom:15px;margin-left:30px;}如果上下左右的边界都为10px;可以这么写：div{ margin:10px;}如果上下边界一样为10px，左右一样为20px，可以这么写：div{ margin:10px 20px;}ps：padding和margin的区别，padding在边框里，margin在边框外。（3）填充padding：元素内容与边框之间是可以设置距离的，称之为填充padding。填充也可分为上、右、下、左（顺序同margin）。（4）内容content：根据具体内容可进行编辑，如分为文本text，图片img等。 布局在网页中，元素有三种布局模型： 1、流动模型（Flow） 流动布局模型具有2个比较典型的特征： 第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，在默认状态下，块状元素的宽度都为100%，会以行的形式占据位置。第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（块状上下，内联左右） 2、浮动模型 (Float) 任何元素在默认情况下是不能浮动的，但可以用CSS定义为浮动，如div、p、table、img等元素都可以被定义为浮动。如下代码可以实现两个div元素一行显示。 div{width:200px;height:200px;border:2px red solid;float:left;}id1```&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; 注意：设置浮动的同时一定要先设置块状元素的宽度，且需要浮动的几个元素宽度加起来一定要小于容器元素的宽度。 3、层模型（Layer） 层模型有三种形式： 1、绝对定位(position: absolute)——相对于父位（参照定位的元素必须加入position:relative;） 这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 2、相对定位(position: relative)——相对于移动前的位置而不是父位 3、固定定位(position: fixed)——相对于网页窗口静止，即拖动滚动条时位置固定不变。（与background-attachment:fixed?属性功能相同） 在有相同权值的情况下，优先顺序是内联式&gt;嵌入式&gt;外部式。 通用选择器 *{CSS内容}；作用于所有标签。 块状元素的居中需要将margin的left、right值设置为auto 。 文本特殊 (1)我的文字后有123456789101112131415 我的文字后有 ```&lt;sup&gt;上标&lt;/sup&gt;```——添加文本的上标 (2) ```&lt;i&gt;字体倾斜&lt;/i&gt;```——istatic (3)```&lt;abbr title=&quot;This is my senior high school teacher&quot;&gt;Teacher&lt;/abbr&gt; ```——缩写，详细信息通过鼠标停留显示26. （1）```&lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;```定义**该文件中**的文本书签tips ```&lt;a href=&quot;file:///Users/thor/Desktop/10.2(1).html#tips&quot; target=&quot;_blank&quot;&gt;有用的提示&lt;/a&gt;```定义指向**其他文件中**的地址的书签（target=&quot;_blank&quot;——新网页打开） （2） ```&lt;a name=&quot;tips&quot;&gt;基本的注意事项-小提示&lt;/a&gt; ```定义后文中tips的位置（name或者id等可以） （3）若想用图片等作为链接点，只需要将对应代码填入```&lt;a href=&quot;想要前往的地址&quot;&gt;&lt;/a&gt;```中。27. &lt;table&gt;制表格时（1） ```&lt;th colspan=&quot;2&quot;&gt;a&lt;/th&gt; 可以构建两**横格**为一格的格子，内容为a；colspan换成rowspan可以构建两**竖格**为一格的格子。 （2）在table属性中加入cellspacing=”xx”可改变单元格间距——单元格间的距离；加入cellpadding可改变单元格边距——单元格的内容与边框的距离。（3）在table属性中加入background=”某图片地址”，可将图片插入表格中。 input相关(1)在input语句（内有list=”XX”为datalist定位)后加入(1)在input语句（内有list=”XX”为datalist定位)后加入 id1```&lt;option value=&quot;...&quot;&gt; value1```... 1234可以使该输入框变为单选，选项为value值。ps：任何需要提交value值给后端的input都必须要加入name=&quot;&quot;属性，从而在后端储存。(2)在input的button等语句中加入onclick=&quot;alert(&apos;声明&apos;)&quot;可以在点击时产生声明动作。如```&lt;input type=&quot;button&quot; onclick=&quot;alert(&apos;Sorry,we are trying to resolve.&apos;)&quot; value=&quot;Any false?&quot;&gt; 插入jstype1插入css```&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;cs地址&quot;/&gt;]]></content>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java笔记综合]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E5%90%8E%E7%AB%AF%E7%89%B9%E6%AE%8A%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[##Java后端特殊细节1.java中的实例变量：**含义：实例变量：定义在类中但在任何方法之外。（New出来的均有初始化）与局部变量的异同：(局部变量：定义在方法之中的变量） 局部变量要先赋值，再进行运算，而实例变量均已经赋初值。 实例变量的对象赋初值为null。 局部变量不允许范围内定义两个同名变量。实例变量的作用域在本类中完全有效，当被其他的类调用的时候也可能有效。 实例变量和局部变量都允许命名冲突。代码实例： 123456789101112131415161718192021222324252627public class Sample&#123;private int a=1; //实例变量public void b()&#123;int a=2; //局部变量System.out.println(&quot;局部变量:a=&quot;+a);System.out.println(&quot;实例变量:a=&quot;+this.a);//局部变量的作用域内引用实例变量方法:this.变量名&#125;public static void main(String[] args)&#123;new Sample().b();&#125;&#125; 2.构造器：构造器就是和类名相同但无返回类型的方法。创建构造器就是构建特定方法。而构造器最大的用处就是在创建对象时执行初始化。每当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。比如 class A { public A() { } } //其中A方法 就是class A的构造器 虽然构造器没有返回值但可以有参数如 class A { public A(String a,String b) { } } 一个类也可以有多个构造器如 class A { public A() { } public A(String a,String b) { } } 当你new A（）时，无参那个构造器被调用，当你new A（”ddd”,”fff”）时，那个有参的构造器被调用，如果你没有写构造器则jvm会调用一个默认的无参的构造器（故调用父类默认构造器的条件：子类没有声明任何构造器；编译器为子类加的缺省构造器一定为无参数的构造器；父类一定要存在一个无参数的构造器）。 PS：构造器在类初始化的时候被调用通常被用来做一些初始化的工作。构造器与方法的具体差异：1、功能和作用的不同构造器是为了创建一个类的实例。用来创建一个对象，同时可以给属性做初始化。这个过程也可以在创建一个对象的时候用到：Platypus p1 = new Platypus(); 相反，方法的作用仅仅是功能函数，执行java代码。 2、修饰符，返回值和命名的不同 和方法一样，构造器可以有任何访问的修饰： public, protected, private或者没有修饰. 不同于方法的是，构造器不能有以下非访问性质的修饰： abstract, final, native, static, 或者 synchronized。 3、返回类型 方法必须要有返回值，能返回任何类型的值或者空返回值（void），构造器没有返回值，也不需要void。 4、命名 构造器使用和类相同的名字，而方法则不同。按照习惯，方法通常用小写字母开始，而构造器通常用大写字母开始。 构造器通常是一个名词，因为它和类名相同；而方法通常更接近动词，因为它说明一个操作。 5、调用 构造：只有在对象创建的时候才会去调用，而且只会调用一次。 方法：在对象创建之后才可以调用，并且可以调用多次。 6、”this”的用法 方法引用this指向正在执行方法的类的实例。静态方法不能使用this关键字，因为静态方法不属于类的实例，所以this也就没有什么东西去指向。构造器的this指向同一个类中，不同参数列表的另外一个构造器。下面的代码： public class Platypus { String name; Platypus(String input) { name = input; } Platypus() { this(&quot;John/Mary Doe&quot;); } public static void main(String args[]) { Platypus p1 = new Platypus(&quot;digger&quot;); Platypus p2 = new Platypus(); } } 在代码中，有2个不同参数列表的构造器。第一个构造器，给类的成员name赋值，第二个构造器，调用第一个构造器，给成员变量name一个初始值 “John/Mary Doe”. 在构造器中，如果要使用关键字this,那么必须放在第一行，如果不这样将导致一个编译错误。7、继承 构造器是不能被继承的。子类可以继承超类的任何方法。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[helloworld]]></title>
    <url>%2F2019%2F02%2F13%2Fhelloworld%2F</url>
    <content type="text"><![CDATA[这篇文章是你好师姐雷猴]]></content>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
